package main

// Automatically generated, do not edit
var webSource = map[string]string{
	"/":       "<!DOCTYPE html>\n<style>body { background: #000309; color: white; padding: 5em; }\ncanvas { margin: 0 auto; display: block }</style>\n<title>NHU</title>\n<script src=\"nhu.js\"></script>\n",
	"/nhu.js": "function _setInterval(f, t) {\n    setInterval(f, t);\n    f();\n}\n\nfunction sourceFetcher(path, cb) {\n    var req, rev, start, source;\n    function setup() {\n        start = performance.now();\n        req = new XMLHttpRequest();\n        req.addEventListener('load', load);\n        req.open('GET', path + (rev ? ('?' + rev) : ''));\n        req.send();\n    }\n\n    function load() {\n        if (req.readyState !== 4)\n            return\n        try {\n            const status = req.status;\n            if (status !== 200) {\n                console.error('status', status);\n                return;\n            }\n            // Updated?\n            if (source === this.responseText)\n                return;\n            source = this.responseText;\n            rev = req.getResponseHeader('X-Revision');\n            cb(source, rev);\n        } finally {\n            next();\n        }\n    }\n\n    function next() {\n        const now = performance.now();\n        if ((now - start) < 1000) {\n            console.log('delay next');\n            setTimeout(setup, 1000);\n        } else {\n            console.log('imm next');\n            setup();\n        }\n    }\n\n    setup();\n}\n\ndocument.addEventListener('DOMContentLoaded', function() {\n    const fhead = `precision mediump float;\nuniform vec2 u_resolution;\nuniform float u_time;\n`;\n    const vsrc = `attribute vec4 position;\nvoid main() {\n    gl_Position = position;\n}`;\n    const fsrc = `void main() { gl_FragColor = vec4(0., 0.2, 0., 1.); }`;\n\n    // TODO: autoscale\n    const width = 720;\n    const height = 500;\n\n    const d = document.createElement('canvas');\n    d.setAttribute('width', width);\n    d.setAttribute('height', height);\n    const gl = d.getContext('webgl');\n    if (!gl) {\n        alert(\"No WebGL\");\n        return;\n    }\n\n    /** OGL SETUP **/\n\n    const prog = gl.createProgram();\n    const vars = {\n        vertex: compileShader(gl.VERTEX_SHADER, vsrc),\n        fragment: compileShader(gl.FRAGMENT_SHADER, fsrc)\n    };\n\n    gl.attachShader(prog, vars.vertex);\n    gl.attachShader(prog, vars.fragment);\n    link();\n    gl.useProgram(prog);\n\n    function link() {\n        gl.linkProgram(prog);\n        vars.position = gl.getAttribLocation(prog, 'position');\n        vars.u_resolution = gl.getUniformLocation(prog, 'u_resolution');\n        vars.u_time = gl.getUniformLocation(prog, 'u_time');\n    }\n\n    /** SHADER **/\n\n    sourceFetcher('shader/fragment',\n        function(text, revision) {\n            console.log('Update shader', revision);\n            const z = compileShader(gl.FRAGMENT_SHADER, text);\n            if (z !== null) {\n                gl.detachShader(prog, vars.fragment);\n                gl.deleteShader(vars.fragment);\n                gl.attachShader(prog, z);\n                link();\n                vars.fragment = z;\n            }\n        });\n\n    /** CANVAS **/\n\n    const buff = gl.createBuffer();\n    const positions = [-1, -1, 1, -1, 1, 1, -1, 1];\n    gl.bindBuffer(gl.ARRAY_BUFFER, buff);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(vars.position, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(vars.position);\n\n    /** DRAW **/\n\n    var start = performance.now() / 1000;\n    requestAnimationFrame(draw);\n\n    function draw() {\n        const u_time = (performance.now() / 1000) - start;\n        gl.useProgram(prog);\n        gl.uniform1f(vars.u_time, u_time);\n        gl.uniform2f(vars.u_resolution, width, height);\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);\n        requestAnimationFrame(draw);\n    }\n\n    function compileShader(type, source) {\n        if (type === gl.FRAGMENT_SHADER) {\n            source = fhead + '\\n' + source;\n        }\n        const shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n            console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\n            gl.deleteShader(shader);\n            return null;\n        }\n        return shader;\n    }\n\n    document.body.appendChild(d);\n});\n",
}
